<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh and object creation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Header -->
  <header class="header">
    <h1 class="logo">Mesh and object creation</h1>
    <a href="../index.html" class="cta-button">Back to Modules</a>
  </header>

  <!-- Main content -->
  <div class="container">
    <h1>Mesh and object creation</h1>
    <p>In Three.js, creating 3D objects, often referred to as "meshes," involves combining two fundamental components: <b>Geometry</b> and <b>Material</b>. These are then used to construct a <code>Mesh</code> object, which is a type of <code>Object3D</code>.</p>

    <h2>Object3D: The Foundation</h2>
    <p><code>Object3D</code> is the base class for almost all objects in Three.js, including meshes, cameras, lights, and groups. It provides properties and methods for manipulating objects in 3D space, such as <code>position</code>, <code>rotation</code>, and <code>scale</code>.</p>

    <h2>Geometry: Defining the Shape</h2>
    <p>Geometry defines the shape and structure of a 3D object. It's essentially a collection of vertices (points in space) and faces (surfaces connecting those vertices). Three.js provides a variety of built-in geometries for common shapes, such as:</p>
    <ul>
        <li><code>BoxGeometry</code> (for cubes and cuboids)</li>
        <li><code>SphereGeometry</code></li>
        <li><code>CylinderGeometry</code></li>
        <li><code>PlaneGeometry</code></li>
        <li><code>TorusGeometry</code></li>
    </ul>
    <p>When creating geometries, it's a best practice to use <code>BufferGeometry</code> (e.g., <code>BoxBufferGeometry</code> instead of <code>BoxGeometry</code>) as it's more memory-efficient and faster.</p>

    <h2>Material: Defining the Appearance</h2>
    <p>Material determines how the surface of a 3D object looks and how it interacts with light. It manages properties like color, texture, transparency, and shininess. Three.js offers various material types, each with different characteristics:</p>
    <ul>
        <li><code>MeshBasicMaterial</code>: A basic material that is not affected by lights.</li>
        <li><code>MeshLambertMaterial</code>: A non-shiny material that reacts to light.</li>
        <li><code>MeshPhongMaterial</code>: A material that produces shiny highlights and reacts to light.</li>
        <li><code>MeshStandardMaterial</code>: A physically based rendering (PBR) material that offers more realistic lighting.</li>
    </ul>
    <p>You can apply textures to materials to add more detail and realism to your objects.</p>

    <h2>Mesh: Combining Geometry and Material</h2>
    <p>A <code>Mesh</code> object is created by combining a <code>Geometry</code> and a <code>Material</code>. It represents the actual 3D object that will be rendered in your scene.</p>

    <h2>Example: Creating a Simple Cube</h2>
    <p>Here's a simple example of creating a cube mesh:</p>
    <pre><code>import * as THREE from 'three';

// 1. Create Geometry
const geometry = new THREE.BoxGeometry(1, 1, 1); // A cube with dimensions 1x1x1

// 2. Create Material
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // A green basic material

// 3. Create Mesh
const cube = new THREE.Mesh(geometry, material);

// Add the cube to your scene (assuming you have a scene set up)
// scene.add(cube);
</code></pre>

    <h2>Best Practices for Object Creation:</h2>
    <ul>
        <li><b>Reuse Geometries and Materials:</b> To optimize performance, reuse the same geometry and material instances for multiple meshes whenever possible.</li>
        <li><b>Use <code>BufferGeometry</code>:</b> Always prefer <code>BufferGeometry</code> over <code>Geometry</code> for better performance.</li>
        <li><b>Minimize Object Count:</b> Reduce the number of individual objects in your scene to improve performance. Consider merging geometries if they share materials.</li>
        <li><b>Object Pooling:</b> Avoid creating new objects inside your render loop, as object creation can be expensive in JavaScript. Reuse existing objects instead.</li>
        <li><b>Center Scene at Origin:</b> Keep your scene centered around the origin (0,0,0) to prevent floating-point errors at large coordinates.</li>
        <li><b>Don't Move the Scene Object:</b> The <code>Scene</code> object should remain at its default position (0,0,0).</li>
    </ul>
  </div>
</body>
</html>